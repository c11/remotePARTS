# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

AtA <- function(A) {
    .Call(`_remoteSTAR_AtA`, A)
}

#' solve Ax = B
#'
#' @param A numeric matrix
#' @param B numeric matrix
#'
#' @export
solve_cpp <- function(A, B) {
    .Call(`_remoteSTAR_solve_cpp`, A, B)
}

#' solve Ax = I
#'
#' @param A numeric matrix
#' @export
solve_ident_cpp <- function(A) {
    .Call(`_remoteSTAR_solve_ident_cpp`, A)
}

#' Find the transposed inverse cholesky decomposition of V
#'
#' @param V numeric matrix
#' @param nugget numeric nugget to add to variance matrix
#'
#' @export
#'
#' @examples #TBA
tinvchol_cpp <- function(V, nugget = 0.) {
    .Call(`_remoteSTAR_tinvchol_cpp`, V, nugget)
}

#' Fit GLS to remote sensing data
#'
#' @details see `fitGLS()`
#'
#' @param X numeric matrix
#' @param V numeric matrix
#' @param y numeric vector
#' @param X0 numeric matrix
#' @param nugget numeric nugget to add to V
#' @param save_xx logical: should xx, xx0, and tInvCholV be returned? This
#' functionality is meant for use with the partitioned GLS whereby these
#' values are used to calculate cross-partition statistics.
#' @param threads integer indicating the number of threads to use. This current
#' version does not have multi-thread functionality so this argument does
#' nothing yet.
#'
#' @export
#' @examples #TBA
fitGLS_cpp <- function(X, V, y, X0, nugget = 0., save_xx = FALSE, threads = 1L) {
    .Call(`_remoteSTAR_fitGLS_cpp`, X, V, y, X0, nugget, save_xx, threads)
}

#' Caculate log-liklihood of GLS model
#'
#' @details this function is mostly meant to optimize the nugget for a paritular
#' set of data.
#'
#' Note: this function should be deprecated and simply added as functionality
#' to `fitGLS_cpp()`.
#'
#' @param nugget the nugget to add to V
#' @param X numeric matrix
#' @param V numeric matrix
#' @param y numeric vector
#'
#' @export
#' @examples #TBA
LogLikGLS_cpp <- function(nugget, X, V, y) {
    .Call(`_remoteSTAR_LogLikGLS_cpp`, nugget, X, V, y)
}

#' Find the maximum likelihood estimate of the nugget
#'
#' @details this is the C++ version of `optimize()` which is specific to
#' finding the nugget value that maximizes the log-liklihood of `fitGLS_cpp()`
#'
#' Note: this function actually uses `LogLikGLS_cpp()` which should be swapped
#' for `fitGLS_cpp()` once the correct funcionality is added.
#'
#' @param X numeric matrix
#' @param V numeric matrix
#' @param y numeric vector
#' @param lower lower boundary for nugget search
#' @param upper upper boundary for nugget search
#' @param tol desired accuracy of nugget search
#' @param debug logical: debug mode?
#'
#' @export
#' @examples #TBA
optimizeNugget_cpp <- function(X, V, y, lower = 0, upper = 1, tol = .00001, debug = FALSE) {
    .Call(`_remoteSTAR_optimizeNugget_cpp`, X, V, y, lower, upper, tol, debug)
}

#' Worker function 1 for paritioned GLS
#'
#' @details this function is the first of 2 (maybe 3) worker functions that,
#' together, perform the partitioned GLS analysis.
#'
#' This function is simply a wrapper for fitGLS_cpp() that finds the MLE nugget
#' and adds it to the output.
#'
#' NOTE: eventually, the worker functions will perform the analysis using
#' multiple cores but that has not yet been implemented.
#'
#' @param y numeric vector
#' @param X numeric matrix
#' @param V numeric matrix
#' @param X0 numeric matrix
#' @param save_xx logical: should xx, xx0, and tInvCholV be returned?
#'
#' @export
#' @examples #TBA
GLS_worker_cpp <- function(y, X, V, X0, save_xx = FALSE) {
    .Call(`_remoteSTAR_GLS_worker_cpp`, y, X, V, X0, save_xx)
}

#' Worker function 2 for partitioned GLS
#'
#' @details this is the second worker function for the partitioned GLS analysis.
#'
#' NOTE: currently, there is no parallel functionality and the partitioned
#' form of the GLS is not implemented entirely in C++. Instead, the R function
#' fitGLS.partition_rcpp() weaves between R and C++ on a single core. While
#' this method is still much faster than the purely R implementation, migration
#' to entirely C++ will greatly improve speed further. This migration requires
#' calculating geographic distances with C++ which I've not yet written.
#'
#' Additionally, there seems to be a memory-related issue with this code. I've
#' successfully used this function when partitions have 100 or fewer rows (too
#' small). However, larger partitions cause a fatal error that causes a crash.
#'
#' @param xxi numeric matrix xx from  partition i
#' @param xxj numeric matrix xx from  partition j
#' @param xxi0 numeric matrix xx0 from  partition i
#' @param xxj0 numeric matrix xx0 from  partition j
#' @param tUinv_i numeric matrix tInvCholV from  partition i
#' @param tUinv_j numeric matrix tInvCholV from  partition j
#' @param Vij numeric variance matrix for Xij
#' @param df1 first degree of freedom
#' @param df2 second degree of freedom
#'
#' @export
#' @examples #TBA
crosspart_worker_cpp <- function(xxi, xxj, xxi0, xxj0, tUinv_i, tUinv_j, nug_i, nug_j, Vij, df1, df2) {
    .Call(`_remoteSTAR_crosspart_worker_cpp`, xxi, xxj, xxi0, xxj0, tUinv_i, tUinv_j, nug_i, nug_j, Vij, df1, df2)
}

