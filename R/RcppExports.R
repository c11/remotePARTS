# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Worker function 1 for paritioned GLS
#'
#' @details this function is the first of 2 (maybe 3) worker functions that,
#' together, perform the partitioned GLS analysis.
#'
#' This function is simply a wrapper for fitGLS_cpp() that finds the MLE nugget
#' and adds it to the output.
#'
#' NOTE: eventually, the worker functions will perform the analysis using
#' multiple cores but that has not yet been implemented.
#'
#' @param y numeric vector
#' @param X numeric matrix
#' @param V numeric matrix
#' @param X0 numeric matrix
#' @param nug_l lower boundary for nugget optimization
#' @param nug_u upper boundary for nugget optimization
#' @param nug_tol tolerance of nugget optimization
#' @param save_xx logical: should xx, xx0, and invcholV be returned?
#'
#' @examples #TBA
.GLS_worker_cpp <- function(y, X, V, X0, nug_l, nug_u, nug_tol, save_xx = FALSE) {
    .Call(`_remotePARTS_GLS_worker_cpp`, y, X, V, X0, nug_l, nug_u, nug_tol, save_xx)
}

#' Caculate log-liklihood of GLS model
#'
#' @details this function is mostly meant to optimize the nugget for a paritular
#' set of data.
#'
#' Note: this function should be deprecated and simply added as functionality
#' to `.fitGLS_cpp()`.
#'
#' @param nugget the nugget to add to V
#' @param X numeric matrix
#' @param V numeric matrix
#' @param y numeric vector
#'
#' @examples #TBA
.LogLikGLS_cpp <- function(nugget, X, V, y) {
    .Call(`_remotePARTS_LogLikGLS_cpp`, nugget, X, V, y)
}

#' Worker function 2 for partitioned GLS
#'
#' @details this is the second worker function for the partitioned GLS analysis.
#'
#' NOTE: currently, there is no parallel functionality and the partitioned
#' form of the GLS is not implemented entirely in C++. Instead, the R function
#' fitGLS.partition_rcpp() weaves between R and C++ on a single core. While
#' this method is still much faster than the purely R implementation, migration
#' to entirely C++ will greatly improve speed further. This migration requires
#' calculating geographic distances with C++ which I've not yet written.
#'
#' Additionally, there seems to be a memory-related issue with this code. I've
#' successfully used this function when partitions have 100 or fewer rows (too
#' small). However, larger partitions cause a fatal error that causes a crash.
#'
#' @param xxi numeric matrix xx from  partition i
#' @param xxj numeric matrix xx from  partition j
#' @param xxi0 numeric matrix xx0 from  partition i
#' @param xxj0 numeric matrix xx0 from  partition j
#' @param tUinv_i numeric matrix invcholV from  partition i
#' @param tUinv_j numeric matrix invcholV from  partition j
#' @param Vsub numeric variance matrix for Xij (upper block)
#' @param nug_i nugget from partition i
#' @param nug_j nugget from partition j
#' @param df1 first degree of freedom
#' @param df2 second degree of freedom
#'
#' @examples #TBA
.crosspart_worker_cpp <- function(xxi, xxj, xxi0, xxj0, tUinv_i, tUinv_j, Vsub, nug_i, nug_j, df1, df2) {
    .Call(`_remotePARTS_crosspart_worker_cpp`, xxi, xxj, xxi0, xxj0, tUinv_i, tUinv_j, Vsub, nug_i, nug_j, df1, df2)
}

#' Fit GLS to remote sensing data
#'
#' @details see `fitGLS()`
#'
#' @param X numeric matrix
#' @param V numeric matrix
#' @param y numeric vector
#' @param X0 numeric matrix
#' @param nugget numeric nugget to add to V
#' @param save_xx logical: should xx, xx0, and invcholV be returned? This
#' functionality is meant for use with the partitioned GLS whereby these
#' values are used to calculate cross-partition statistics.
#' @param threads integer indicating the number of threads to use. This current
#' version does not have multi-thread functionality so this argument does
#' nothing yet.
#'
#' @examples #TBA
.fitGLS_cpp <- function(X, V, y, X0, nugget, save_xx, threads) {
    .Call(`_remotePARTS_fitGLS_cpp`, X, V, y, X0, nugget, save_xx, threads)
}

#' Fit GLS to remote sensing data
#'
#' @details see `fitGLS()`
#'
#' @param X numeric matrix
#' @param V numeric matrix
#' @param y numeric vector
#' @param X0 numeric matrix
#' @param nugget numeric nugget to add to V
#' @param save_xx logical: should xx, xx0, and invcholV be returned? This
#' functionality is meant for use with the partitioned GLS whereby these
#' values are used to calculate cross-partition statistics.
#' @param threads integer indicating the number of threads to use. This current
#' version does not have multi-thread functionality so this argument does
#' nothing yet.
#'
#' @examples #TBA
.fitGLS2_cpp <- function(L, X, V, y, X0, nugget, save_xx, threads) {
    invisible(.Call(`_remotePARTS_fitGLS2_cpp`, L, X, V, y, X0, nugget, save_xx, threads))
}

#' caculate t(A) \%*\% A
#'
#' @param A numeric matrix
#'
.AtA <- function(A) {
    .Call(`_remotePARTS_AtA`, A)
}

#' solve Ax = B for x
#'
#' @param A numeric matrix
#' @param B numeric matrix
#'
.solve_cpp <- function(A, B) {
    .Call(`_remotePARTS_solve_cpp`, A, B)
}

#' solve Ax = I for x
#'
#' @param A numeric matrix
#'
.solve_ident_cpp <- function(A) {
    .Call(`_remotePARTS_solve_ident_cpp`, A)
}

#' Invert the cholesky decomposition of V
#'
#' @param V numeric matrix
#' @param nugget numeric nugget to add to variance matrix
#'
#' @examples #TBA
.invchol_cpp <- function(V, nugget = 0.) {
    .Call(`_remotePARTS_invchol_cpp`, V, nugget)
}

#' Find the maximum likelihood estimate of the nugget
#'
#' @details this is the C++ version of `optimize()` which is specific to
#' finding the nugget value that maximizes the log-likelihood of `fitGLS_cpp()`
#'
#' This function is a translation from the forchan algorithm fmin into C++:
#' http://www.netlib.org/fmm/fmin.f
#'
#' Note: this function actually uses `LogLikGLS_cpp()` which should be swapped
#' for `fitGLS_cpp()` once the correct functionality is added to the latter.
#'
#' @param X numeric matrix
#' @param V numeric matrix
#' @param y numeric vector
#' @param lower lower boundary for nugget search
#' @param upper upper boundary for nugget search
#' @param tol desired accuracy of nugget search
#' @param debug logical: debug mode?
#'
#' @examples #TBA
.optimize_nugget_cpp <- function(X, V, y, lower, upper, tol, debug) {
    .Call(`_remotePARTS_optimize_nugget_cpp`, X, V, y, lower, upper, tol, debug)
}

