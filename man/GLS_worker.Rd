% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/worker-functions_GLS.R
\name{GLS_worker}
\alias{GLS_worker}
\title{Worker function 1 for paritioned GLS}
\usage{
GLS_worker(
  y,
  X,
  V,
  X0,
  nug_l = 0,
  nug_u = 1,
  nug_tol = 1e-05,
  save_xx = FALSE,
  threads = 1
)
}
\arguments{
\item{y}{numeric vector}

\item{X}{numeric matrix}

\item{V}{numeric matrix}

\item{X0}{numeric matrix}

\item{nug_l}{lower boundary for nugget optimization}

\item{nug_u}{upper boundary for nugget optimization}

\item{nug_tol}{tolerance of nugget optimization}

\item{save_xx}{logical: should xx, xx0, and invcholV be returned?}

\item{threads}{number of threads used by Eigen for matrix algebra}
}
\value{
a list of remoteGLS output
}
\description{
Worker function 1 for paritioned GLS
}
\details{
\code{GLS_worker()} is meant to be called by other functions
and performs GLS similar to \code{fitGLS()}. However, unlike \code{fitGLS()},
the nugget is optimized each time the function is called. This additional
step is ideal for partitioned GLS.

At present, \code{GLS_worker()} is only single-core natively but will have
multi-core functionality eventually.
}
\examples{

}
\seealso{
[fitGLS()] and [fitGLS.parition_rcpp()]

Other remoteGLS: 
\code{\link{crosspart_worker}()}
}
\concept{remoteGLS}
