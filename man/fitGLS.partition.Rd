% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fitGLS_partition.R
\name{fitGLS.partition}
\alias{fitGLS.partition}
\alias{fitGLS.partition.mc}
\title{Partitioned GLS}
\usage{
fitGLS.partition(
  part_f = "part_csv",
  dist_f = "dist_km",
  V.meth = "exponential",
  spatcor,
  partsize,
  npart,
  mincross = 6,
  threads = 1,
  ...
)

fitGLS.partition.mc(
  part_f = "part_csv",
  dist_f = "dist_km",
  V.meth = "exponential",
  spatcor,
  partsize,
  npart,
  mincross = 6,
  ncores = parallel::detectCores() - 1,
  export = NA,
  debug = TRUE,
  ...
)
}
\arguments{
\item{part_f}{function to partition data. See details for more info}

\item{dist_f}{function to calculate distance. See details for more info}

\item{V.meth}{method passed to \code{fitV()}}

\item{spatcor}{spatial correlation used by \code{fitV()}}

\item{partsize}{number of pixels in each partition}

\item{npart}{number of partitions}

\item{mincross}{number of partition pairs to calculate cross-partition
statistics from.}

\item{threads}{number of threads used by Eigen for matrix algebra}

\item{...}{additional arguments passed to \code{part_f}}

\item{ncores}{number of cores for parallel processing. Default is total cores - 1}

\item{export}{an optional character vector of names for any additional objects
needed for \code{part_f()}.}

\item{debug}{logical debug flag. If TRUE, prints the name of the step that is running}
}
\description{
Fit a partitioned GLS using the PARTS and calculate
cross-partition statitics.
}
\details{
\code{fitGLS.partition()} calls the function specified by \code{part_f} to
get the partitions. \code{part_f} is called \code{npart} times and uses an
iterator as the first argument (i.e. \code{part_f(1)},
\code{part_f(2)}, ... \code{part_f(npart)}). A GLS is fit to each partition
and cross-partition statistics are calculated for each pair of partitions up
to the smaller of \code{mincross} and \eqn{\code{npart} - 1}.

\code{part_f} can be any function that takes an integer i (from 1 to
\code{npart}) as its first argument and whose output is a list with at
least the following elements:

\describe{
    \item{\code{$y}}{the response vector of length \code{partsize}
    corresponding to parition i}
    \item{\code{$X}}{a model matrix for parition i}
    \item{\code{$coords}}{a matrix or data frame of spatial coordinates for
    partition i. The first column are x coordinates and the second are y
    coordinates}
}

\code{dist_f} can be any function that returns a distance matrix. This
function should be able to calculate pairwise distances from a single
coordinate matrix and should also be able to calculate distances from
a pair of coordinate matrices (as in \code{distgeo::distm()}).
\code{dist_km()} is an example of an appropriate distance function and
is the default for \code{GLS.partition}.
}
\examples{
n.pix = 30865 # pixels in AK_ndvi_common-land.csv
parts = sample_partitions(npix = n.pix, npart = 4, partsize = 200) # small partition matrix
data.file = system.file("extdata", "AK_ndvi_common-land.csv",
                        package = "remotePARTS")

# Fit the partitioned GLS
GLS.part = fitGLS.partition(part_f = "part_csv", dist_f = "dist_km",
                            partsize = nrow(parts), npart = ncol(parts),
                            V.meth = "exponential", spatcor = .5,
                            # additional arguments passed to part_csv():
                            part_csv_path = data.file, part_mat = parts,
                            part_form = "cls.coef ~ 0 + land",
                            part_form0 = "cls.coef ~ 1")
## now w. 2 cores:

if(FALSE){ # change to TRUE to run multi-core version
  GLS.part.mc = fitGLS.partition.mc(part_f = "part_csv", dist_f = "dist_km",
                                    partsize = nrow(parts), npart = ncol(parts),
                                    V.meth = "exponential", spatcor = .5,
                                    part_csv_path = data.file, part_mat = parts,
                                    part_form = "cls.coef ~ 0 + land",
                                    part_form0 = "cls.coef ~ 1",
                                    ncores = 4)
}
}
\seealso{
[fitGLS()], [sample_partition()], [calc_df()], [dist_km()],
[part_csv()], [geosphere::distgeo()],
}
