% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimize_GLS.R
\name{optim_GLS_func}
\alias{optim_GLS_func}
\alias{optimize_GLS}
\title{function to optimize GLS parameters r, a, and nugget}
\usage{
optim_GLS_func(
  par,
  y,
  modmat,
  D,
  verbose = FALSE,
  V.meth = "exponential-power"
)

optimize_GLS(
  formula,
  coords,
  dist_f = "dist_km",
  V.meth = "exponential-power",
  nugget = NA,
  spcor = NA,
  verbose = FALSE,
  contrasts = NULL,
  data,
  pars.start = c(r = 0.1, a = 1, nug = 1e-09),
  save_xx = F,
  ret.GLS = TRUE,
  ...
)
}
\arguments{
\item{par}{parameters to optimize}

\item{y}{response vector}

\item{modmat}{predictor model matrix}

\item{D}{distance matrix}

\item{verbose}{should additional info be printed?}

\item{V.meth}{covariance method for fitting V}

\item{formula}{model formula}

\item{coords}{2-column matrix of x and y coordinates}

\item{dist_f}{distance function to use}

\item{nugget}{spatial nugget. If NA, a nugget will be estimated}

\item{spcor}{spatial correlation paramters either NA, a single value (r) or
a named vector: c(r = ..., a = ...). if spcor = NA, these parameters will be
estimated}

\item{contrasts}{linear contrasts to apply}

\item{data}{data object for which formula tries to match}

\item{pars.start}{default starting values for the spcor}

\item{save_xx}{save cross correlation stats?}

\item{ret.GLS}{return GLS?}

\item{...}{additional arguments passed to \code{fitGLS2()}}
}
\value{
a remoteGLS object
}
\description{
function to optimize GLS parameters r, a, and nugget

Fit a GLS by estimating r, a, and nugget
}
\examples{
set.seed(916)

## load Alaska 3000 data
data("ndvi_AK3000")

## take a random subset of 100 pixels (to make example fast)
subsamp = sample.int(n = nrow(ndvi_AK3000), size = 100)

## subset the data: we now have 100 pixels, latitude, longitude, and land class
df = ndvi_AK3000[subsamp, c("lng", "lat", "land")] # subset the data

## simulate a response variable kappa
df$kappa = .5*df$lat + .2*df$lng + rnorm(100) #simulate response variable

## calculate distance matrix
D = geosphere::distm(df[, c("lng", "lat")])/1000 #distance in km

## fit the GLS, including ML spatial correlation and nugget
optimize_GLS(kappa ~ 0 + land, data = df, coords = df[, c("lng", "lat")], verbose = FALSE)
}
\seealso{
[fitGLS2()]
}
